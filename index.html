<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simple SPC Tool (Run & XmR)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 1.5rem;
      max-width: 900px;
    }
    h1 {
      margin-bottom: 0.25rem;
    }
    .sub {
      margin-top: 0;
      color: #555;
      font-size: 0.9rem;
    }
    .panel {
      padding: 1rem;
      border-radius: 0.5rem;
      border: 1px solid #ddd;
      margin-bottom: 1rem;
    }
    label {
      display: inline-block;
      margin-right: 0.5rem;
      margin-top: 0.5rem;
    }
    select, input[type="file"], button {
      margin-top: 0.25rem;
      margin-bottom: 0.5rem;
    }
    button {
      padding: 0.4rem 0.8rem;
      border-radius: 0.4rem;
      border: 1px solid #0078d4;
      background: #0078d4;
      color: white;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .chart-container {
      margin-top: 1rem;
      height: 400px;
    }
    .hint {
      font-size: 0.8rem;
      color: #666;
    }
    .error {
      color: #b00020;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <h1>Simple SPC Web Tool</h1>
  <p class="sub">Upload a CSV, pick your columns, and draw a Run chart or XmR chart in the browser.</p>

  <div class="panel">
    <div>
      <label for="fileInput"><strong>1. Upload CSV file:</strong></label><br />
      <input type="file" id="fileInput" accept=".csv" />
      <div class="hint">
        Expected columns: a date/time column (e.g. <code>Date</code>) and a numeric column (e.g. <code>Value</code>).
      </div>
    </div>

    <div id="columnSelectors" style="display: none;">
      <hr />
      <strong>2. Choose columns:</strong><br />

      <label>Date column:
        <select id="dateColumn"></select>
      </label>

      <label>Value column:
        <select id="valueColumn"></select>
      </label>

      <br />
      <strong>3. Chart type:</strong><br />
      <label>
        <input type="radio" name="chartType" value="run" checked />
        Run chart (median only)
      </label>
      <label>
        <input type="radio" name="chartType" value="xmr" />
        XmR chart (mean + control limits)
      </label>

      <br /><br />
      <button id="generateButton">Generate chart</button>
      <span class="hint">Data never leaves your browser.</span>
      <div id="errorMessage" class="error"></div>
    </div>
  </div>

  <div class="panel">
    <strong>4. Chart:</strong>
    <div class="chart-container">
      <canvas id="spcChart"></canvas>
    </div>
  </div>

  <script>
    let rawRows = [];
    let currentChart = null;

    const fileInput = document.getElementById("fileInput");
    const columnSelectors = document.getElementById("columnSelectors");
    const dateSelect = document.getElementById("dateColumn");
    const valueSelect = document.getElementById("valueColumn");
    const generateButton = document.getElementById("generateButton");
    const errorMessage = document.getElementById("errorMessage");
    const chartCanvas = document.getElementById("spcChart");

    fileInput.addEventListener("change", () => {
      const file = fileInput.files[0];
      if (!file) return;

      errorMessage.textContent = "";

      Papa.parse(file, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: (results) => {
          const rows = results.data;
          if (!rows || rows.length === 0) {
            errorMessage.textContent = "No rows found in this CSV.";
            return;
          }
          rawRows = rows;
          const firstRow = rows[0];
          const columns = Object.keys(firstRow);

          // Populate dropdowns
          dateSelect.innerHTML = "";
          valueSelect.innerHTML = "";

          columns.forEach(col => {
            const opt1 = document.createElement("option");
            opt1.value = col;
            opt1.textContent = col;
            dateSelect.appendChild(opt1);

            const opt2 = document.createElement("option");
            opt2.value = col;
            opt2.textContent = col;
            valueSelect.appendChild(opt2);
          });

          columnSelectors.style.display = "block";
        },
        error: (err) => {
          errorMessage.textContent = "Error parsing CSV: " + err.message;
        }
      });
    });

    function getSelectedChartType() {
      const radios = document.querySelectorAll("input[name='chartType']");
      for (const r of radios) {
        if (r.checked) return r.value;
      }
      return "run";
    }

    function computeMedian(values) {
      const sorted = [...values].sort((a, b) => a - b);
      const n = sorted.length;
      if (n === 0) return NaN;
      if (n % 2 === 1) return sorted[(n - 1) / 2];
      return (sorted[n / 2 - 1] + sorted[n / 2]) / 2;
    }

    function computeXmR(points) {
      // sort by date
      points.sort((a, b) => a.x - b.x);

      const mean = points.reduce((s, p) => s + p.y, 0) / points.length;

      const mrs = [];
      for (let i = 1; i < points.length; i++) {
        mrs.push(Math.abs(points[i].y - points[i - 1].y));
      }
      const avgMR = mrs.reduce((s, v) => s + v, 0) / mrs.length;
      const sigma = avgMR / 1.128; // d2 for n=2

      const ucl = mean + 3 * sigma;
      const lcl = mean - 3 * sigma;

      const flaggedPoints = points.map((p) => ({
        ...p,
        beyondLimits: p.y > ucl || p.y < lcl
      }));

      return { points: flaggedPoints, mean, ucl, lcl };
    }

    generateButton.addEventListener("click", () => {
      errorMessage.textContent = "";

      if (!rawRows || rawRows.length === 0) {
        errorMessage.textContent = "Please upload a CSV file first.";
        return;
      }

      const dateCol = dateSelect.value;
      const valueCol = valueSelect.value;

      if (!dateCol || !valueCol) {
        errorMessage.textContent = "Please choose both a date column and a value column.";
        return;
      }

      const parsedPoints = rawRows
        .map((row) => {
          const dateRaw = row[dateCol];
          const valueRaw = row[valueCol];
          const d = new Date(dateRaw);
          const y = Number(valueRaw);

          if (!isFinite(d.getTime()) || !isFinite(y)) {
            return null;
          }
          return { x: d, y };
        })
        .filter((p) => p !== null);

      if (parsedPoints.length < 5) {
        errorMessage.textContent = "Not enough valid data points after parsing. Check your column choices.";
        return;
      }

      const chartType = getSelectedChartType();

      if (currentChart) {
        currentChart.destroy();
        currentChart = null;
      }

      if (chartType === "run") {
        drawRunChart(parsedPoints);
      } else {
        drawXmRChart(parsedPoints);
      }
    });

    function drawRunChart(points) {
      points.sort((a, b) => a.x - b.x);
      const labels = points.map(p => p.x.toISOString().slice(0, 10));
      const values = points.map(p => p.y);
      const median = computeMedian(values);

      currentChart = new Chart(chartCanvas, {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: "Value",
              data: values,
              pointRadius: 4,
              borderWidth: 2,
              fill: false
            },
            {
              label: "Median",
              data: values.map(() => median),
              borderDash: [6, 4],
              borderWidth: 1,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: "Run Chart"
            }
          }
        }
      });
    }

    function drawXmRChart(points) {
      const { points: pts, mean, ucl, lcl } = computeXmR(points);

      // sort again by x, just to be sure
      pts.sort((a, b) => a.x - b.x);

      const labels = pts.map(p => p.x.toISOString().slice(0, 10));
      const values = pts.map(p => p.y);
      const pointColours = pts.map(p => (p.beyondLimits ? "red" : "blue"));

      currentChart = new Chart(chartCanvas, {
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: "Value",
              data: values,
              pointRadius: 4,
              pointBackgroundColor: pointColours,
              borderWidth: 2,
              fill: false
            },
            {
              label: "Mean",
              data: values.map(() => mean),
              borderDash: [6, 4],
              borderWidth: 1,
              fill: false
            },
            {
              label: "UCL",
              data: values.map(() => ucl),
              borderDash: [4, 4],
              borderWidth: 1,
              fill: false
            },
            {
              label: "LCL",
              data: values.map(() => lcl),
              borderDash: [4, 4],
              borderWidth: 1,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: "XmR Chart (points beyond limits shown in red)"
            }
          }
        }
      });
    }
  </script>
</body>
</html>
